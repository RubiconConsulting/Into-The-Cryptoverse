// SPDX-License-Identifier: MIT
pragma solidity >=0.8.24;

import {Script} from "forge-std/Script.sol";
import {console} from "forge-std/console.sol";
import {StoreSwitch} from "@latticexyz/store/src/StoreSwitch.sol";

import {IWorld} from "../src/codegen/world/IWorld.sol";
import {MapConfig, Position, Dice} from "../src/codegen/index.sol";
import {BlockType} from "../src/codegen/common.sol";

contract PostDeploy is Script {
    function run(address worldAddress) external {
        // Specify a store so that you can use tables directly in PostDeploy
        StoreSwitch.setStoreAddress(worldAddress);

        // Load the private key from the `PRIVATE_KEY` environment variable (in .env)
        uint256 deployerPrivateKey = vm.envUint("PRIVATE_KEY");

        // Start broadcasting transactions from the deployer account
        vm.startBroadcast(deployerPrivateKey);
        BlockType S = BlockType.Standard;
        BlockType F = BlockType.Flash;
        BlockType A = BlockType.Action;
        BlockType T = BlockType.Trap;
        BlockType Q = BlockType.Question;

        // init the map with the following block types
        // TODO - this is a hardcoded map, make it auto-generated by a seed,seed can generated by Chainlink VRF
        BlockType[20][20] memory map = [
            [S, S, S, S, S, S, T, S, S, S, S, S, S, S, S, S, S, S, S, S],
            [S, S, T, S, S, S, S, S, T, S, S, S, S, F, S, S, S, S, S, S],
            [S, T, T, T, T, S, S, S, S, S, S, S, S, S, S, T, T, S, S, S],
            [S, S, T, T, T, T, S, S, S, S, F, S, S, S, S, S, T, S, S, S],
            [S, S, S, S, T, T, S, S, S, S, S, S, S, S, S, S, S, T, S, S],
            [S, S, S, F, F, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S],
            [S, T, S, S, S, F, F, S, S, S, S, T, S, S, S, S, S, F, S, S],
            [S, S, T, T, S, S, S, S, S, T, S, F, S, S, T, S, F, S, S, S],
            [S, S, T, S, S, S, S, T, T, T, S, F, F, S, S, S, S, S, S, S],
            [S, S, S, S, S, S, S, T, T, T, S, F, T, S, T, T, S, S, S, S],
            [S, F, S, S, S, F, S, S, T, T, S, F, S, S, T, T, S, S, S, S],
            [S, S, F, S, S, S, T, S, T, T, S, S, F, T, T, T, S, S, S, S],
            [S, S, F, F, S, S, S, S, T, S, S, S, F, S, T, S, S, S, S, S],
            [S, S, S, F, F, S, S, S, S, S, S, S, S, F, S, T, S, S, S, S],
            [S, S, S, S, F, S, S, S, S, S, S, S, S, S, S, S, S, S, S, S],
            [S, S, S, S, S, S, S, S, S, S, F, F, S, S, T, S, S, S, S, S],
            [S, S, S, S, T, S, S, S, T, F, S, S, S, T, T, S, F, S, S, S],
            [S, S, S, T, S, T, T, T, S, S, S, S, S, T, S, S, S, S, S, S],
            [S, S, S, T, T, T, T, S, S, S, S, T, S, S, S, T, S, S, S, S],
            [S, Q, S, S, S, T, S, S, S, S, S, S, S, A, S, S, S, S, S, S]
        ];

        uint32 height = uint32(map.length);
        uint32 width = uint32(map[0].length);

        bytes memory terrain = new bytes(width * height);

        for (uint32 y = 0; y < height; y++) {
            for (uint32 x = 0; x < width; x++) {
                BlockType blockType = map[y][x];
                if (blockType == BlockType.Standard) continue;

                terrain[(y * width) + x] = bytes1(uint8(blockType));
            }
        }
        MapConfig.set(width, height, terrain);
        vm.stopBroadcast();
    }
}
